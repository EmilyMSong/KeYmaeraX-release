/**
* Copyright (c) Carnegie Mellon University.
* See LICENSE.txt for the conditions of this license.
*/

import edu.cmu.cs.ls.keymaerax.btactics.TacticTestBase
import edu.cmu.cs.ls.keymaerax.btactics.TactixLibrary.skip
import edu.cmu.cs.ls.keymaerax.core.{False, Function, Real}
import edu.cmu.cs.ls.keymaerax.parser.StringConverter._

/**
  * Tests that exploit unsound implicit definitions.
  *
  * @author James Gallicchio
  */
class KnownImplicitExploitTests extends TacticTestBase {

  "implicit defs" should "not allow non-unique definitions" in withMathematica { _ =>
    val bad = Function(name="bad",domain=Real,sort=Real,interp=Some(
      /* bad(._1) = . <-> */ ". = 0 | . = 1".asFormula)
    )

    val pvble = proveBy(False,
      skip //TODO
    )

    pvble should not be 'proved
  }

  it should "not allow non-continuous definitions" in withMathematica { _ =>
    val stepDown = Function(name="stepDown",domain=Real,sort=Real,interp=Some(
      /* stepDown(._1) = . <-> */ "._1 <= 0 & . = 1 | ._1 > 0 & . = 0".asFormula)
    )

    val pvble = proveBy(False,
      skip //TODO
    )

    pvble should not be 'proved
  }

  it should "not allow non-smooth definitions" in withMathematica { _ =>
    // abs is non-smooth already, should be able to prove false from it

    val pvble = proveBy(False,
      skip //TODO
    )

    pvble should not be 'proved
  }

}
