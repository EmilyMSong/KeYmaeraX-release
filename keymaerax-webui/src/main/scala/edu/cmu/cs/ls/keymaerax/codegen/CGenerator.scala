/**
 * Copyright (c) Carnegie Mellon University. CONFIDENTIAL
 * See LICENSE.txt for the conditions of this license.
 */
package edu.cmu.cs.ls.keymaerax.codegen

import edu.cmu.cs.ls.keymaerax.codegen.CFormulaTermGenerator._
import edu.cmu.cs.ls.keymaerax.codegen.CGenerator._
import edu.cmu.cs.ls.keymaerax.core._
import edu.cmu.cs.ls.keymaerax.parser.{Declaration, Name, Signature}

object CGenerator {
  /** Prints a file header */
  def printHeader(modelName: String): String =
    s"""/**************************
       | *${if(modelName.nonEmpty) " " + modelName + ".c" else ""}
       | * Generated by KeYmaera X
       | **************************/
       |
       |""".stripMargin

  /** Prints include statements. */
  val INCLUDE_STATEMENTS: String =
    """#include <math.h>
      |#include <stdbool.h>
      |
      |""".stripMargin

  /** Prints the parameters struct declaration. */
  def printParameterDeclaration(parameters: Set[NamedSymbol]): String = printStructDeclaration("parameters", parameters, "Model parameters")

  /** Prints the state variables struct declaration. */
  def printStateDeclaration(stateVars: Set[BaseVariable]): String = printStructDeclaration("state", stateVars, "State (control choices, environment measurements etc.)")

  /** Prints the input (non-deterministically assigned variables) struct declaration. */
  def printInputDeclaration(inputs: Set[BaseVariable]): String = printStructDeclaration("input", inputs, "Values for resolving non-deterministic assignments in control code")

  /** Prints the verdict struct declaration with documentation comment. */
  def printVerdictDeclaration(): String =
    """/** Monitor verdict: `id` identifies the violated monitor sub-condition, `val` the safety margin (<0 violated, >=0 satisfied). */
      |typedef struct verdict { int id; long double val; } verdict;
      |
      |""".stripMargin
}

/**
  * C++ code generator that prints a file header, include statements, declarations, and the output of `bodyGenerator`.
  * @author Ran Ji
  * @author Stefan Mitsch
  */
class CGenerator(bodyGenerator: CodeGenerator, defs: Declaration = Declaration(Map.empty)) extends CodeGenerator {
  /** Generate C Code for given expression using the data type cDataType throughout and the input list of variables */
  override def apply(expr: Expression, stateVars: Set[BaseVariable], inputVars: Set[BaseVariable], fileName: String): (String, String) =
    generateMonitoredCtrlCCode(expr, stateVars, inputVars, fileName)

  /** The name of the monitor/control function argument representing monitor parameters. */
  private val FUNC_PARAMS_NAME = "params"

  /** Compiles primitive expressions with the appropriate params/curr/pre struct location. */
  private def primitiveExprGenerator(parameters: Set[NamedSymbol]) = new CFormulaTermGenerator({
    case t: Variable =>
      if (parameters.contains(t)) FUNC_PARAMS_NAME + "->"
      else ""
    case FuncOf(fn, Nothing) =>
      if (parameters.contains(fn)) FUNC_PARAMS_NAME + "->"
      else throw new CodeGenerationException("Non-posterior, non-parameter function symbol " + fn.prettyString + " is not supported")
  })

  /** Prints function definitions of symbols in `mentionedIn`. */
  private def printFuncDefs(mentionedIn: Expression, defs: Declaration, parameters: Set[NamedSymbol], printed: Set[NamedSymbol] = Set.empty): String = {
    val what = StaticSemantics.symbols(mentionedIn) -- printed
    val printing = defs.decls.
      filter({
        case (n, s@Signature(_, Real | Bool, Some(args), _, _)) => args.nonEmpty && what.contains(Declaration.asNamedSymbol(n, s))
        case _ => false })
    printing.map({
        case (name, Signature(_, codomain, Some(args), interpretation, _)) =>
          def ctype(s: Sort): String = s match {
            case Real => "long double"
            case Bool => "bool"
            case _ => throw new IllegalArgumentException("Sort " + s + " not supported")
          }
          val cargs = args.map({ case (n, s) => s"${ctype(s)} ${n.prettyString}" }).mkString(", ")
          //@note ensure that args don't have both . and ._0
          assert(interpretation.forall(StaticSemantics.symbols(_).flatMap({
            case DotTerm(_, Some(i)) => Some(i)
            case DotTerm(_, None) => Some(0)
            case _ => None
          }).count(_ == 0) <= 1))
          val argsSubst = USubst(args.zipWithIndex.flatMap({ case ((Name(n, idx), s), i) =>
            (if (i == 0) List(SubstitutionPair(DotTerm(s, None), Variable(n, idx, s))) else Nil) :+
              SubstitutionPair(DotTerm(s, Some(i)), Variable(n, idx, s)) }))
          val (interpretationDefs, body) = interpretation match {
            case Some(i) =>
              (printFuncDefs(i, defs, parameters, printed ++ printing.map({ case (n, s) => Declaration.asNamedSymbol(n, s) }).toSet),
                primitiveExprGenerator(parameters)(argsSubst(i))._2)
            case _ => ("", "0; /* todo */")
          }
          s"""$interpretationDefs
             |${ctype(codomain)} ${name.prettyString}(const parameters* const $FUNC_PARAMS_NAME, $cargs) {
             |  return $body;
             |}""".stripMargin
      }).mkString("\n\n") + "\n\n"
  }

  /** Generates a monitor `expr` that switches between a controller and a fallback controller depending on the monitor outcome. */
  private def generateMonitoredCtrlCCode(expr: Expression, stateVars: Set[BaseVariable], inputVars: Set[BaseVariable], fileName: String) : (String, String) = {
    val names = StaticSemantics.symbols(expr).map(nameIdentifier)
    require(names.intersect(RESERVED_NAMES).isEmpty, "Unexpected reserved C names encountered: " + names.intersect(RESERVED_NAMES).mkString(","))
    val parameters = CodeGenerator.getParameters(defs.exhaustiveSubst(expr), stateVars)

    val (bodyBody, bodyDefs) = bodyGenerator(expr, stateVars, inputVars, fileName)

    (printHeader(fileName) +
      INCLUDE_STATEMENTS +
      printParameterDeclaration(parameters) +
      printStateDeclaration(stateVars) +
      printInputDeclaration(inputVars) +
      printVerdictDeclaration +
      printFuncDefs(expr, defs, parameters) +
      bodyDefs, bodyBody)
  }

  private val RESERVED_NAMES = Set("main", "Main")
}