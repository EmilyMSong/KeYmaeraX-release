/**
 * Copyright (c) Carnegie Mellon University. CONFIDENTIAL
 * See LICENSE.txt for the conditions of this license.
 */
package edu.cmu.cs.ls.keymaerax.codegen

import edu.cmu.cs.ls.keymaerax.codegen.PythonPrettyPrinter.{nameIdentifier, printSort}
import edu.cmu.cs.ls.keymaerax.codegen.PythonGenerator.{IMPORT_STATEMENTS, printHeader, printInputDeclaration, printParameterDeclaration, printStateDeclaration, printVerdictDeclaration}
import edu.cmu.cs.ls.keymaerax.core._
import edu.cmu.cs.ls.keymaerax.parser.{Declaration, Name, Signature}

/**
  * Python code generator header and declaration printing.
  * @author Stefan Mitsch
  */
object PythonGenerator {
  val RESERVED_NAMES = Set("self", "in", "val", "bool", "def", "int", "float")

  /** Prints a file header */
  def printHeader(modelName: String): String =
    s"""#
       |# ${if(modelName.nonEmpty) modelName + ".py" else ""}
       |# Generated by KeYmaera X
       |#
       |
       |""".stripMargin

  /** Prints import statements. */
  val IMPORT_STATEMENTS: String =
    """from typing import Callable
      |import numpy as np
      |
      |""".stripMargin

  /** Prints a class declaration of class `name` with `fields` and documentation `comment`. */
  def printClassDeclaration[T <: NamedSymbol](name: String, fields: Set[T], comment: String): String = {
    val sortedVars = fields.toList.sorted[NamedSymbol]
    val names = sortedVars.map({
      case x: Variable => nameIdentifier(x) -> printSort(x.sort)
      case f: Function =>
        assert(!CodeGenerator.isInterpreted(f), "Parameter must not be an interpreted function")
        assert(f.domain == Unit, "If declared as function, parameter must have domain Unit, but has " + f.domain)
        nameIdentifier(f) -> printSort(f.sort)
    })
    val fieldDecls = names.map({ case (n, s) => n + ": " + s })
    val setFields = names.map(_._1).map(s => s"self.$s = $s")
    val printFields = names.map(_._1).map(s => s""""$s=" + str(self.$s)""").mkString(""" + ", " + """)
    val body = if (names.isEmpty) "self" else setFields.mkString("\n    ")
    s"""# $comment
       |class $name:
       |  def __init__(self${{if (fieldDecls.nonEmpty) ", " else ""} + fieldDecls.mkString(", ")}):
       |    $body
       |  def __str__(self) -> str:
       |    return "$name(" + ${if (names.nonEmpty) printFields + " + " else ""} ")"
       |
       |""".stripMargin
  }

  /** Prints the parameters class declaration. */
  def printParameterDeclaration(parameters: Set[NamedSymbol]): String = printClassDeclaration("Params", parameters, "Model parameters")

  /** Prints the state variables class declaration. */
  def printStateDeclaration(stateVars: Set[BaseVariable]): String = printClassDeclaration("State", stateVars, "State (control choices, environment measurements etc.)")

  /** Prints the input (non-deterministically assigned variables) class declaration. */
  def printInputDeclaration(inputs: Set[BaseVariable]): String = printClassDeclaration("Input", inputs, "Values for resolving non-deterministic assignments in control code")

  /** Prints the verdict class declaration. */
  def printVerdictDeclaration(): String = printClassDeclaration("Verdict", Set(Variable("id"), Variable("val")), "Verdict identifier and value")
}

/**
  * Python code generator that prints a file header, include statements, declarations, and the output of `bodyGenerator`.
  * @author Stefan Mitsch
  */
class PythonGenerator(bodyGenerator: CodeGenerator, defs: Declaration = Declaration(Map.empty)) extends CodeGenerator {
  /** Generate Python code for given expression using the data type cDataType throughout and the input list of variables */
  override def apply(expr: Expression, stateVars: Set[BaseVariable], inputVars: Set[BaseVariable], fileName: String): (String, String) =
    generateMonitoredCtrlCCode(expr, stateVars, inputVars, fileName)

  /** Prints function definitions of symbols in `mentionedIn`. */
  private def printFuncDefs(mentionedIn: Expression, defs: Declaration): String = {
    val what = StaticSemantics.symbols(mentionedIn)
    defs.decls.
      filter({
        case (n, s@Signature(_, Real | Bool, Some(args), _, _)) => args.nonEmpty && what.contains(Declaration.asNamedSymbol(n, s))
        case _ => false }).
      map({
        case (name, Signature(_, codomain, Some(args), interpretation, _)) =>
          def ptype(s: Sort): String = s match {
            case Real => "np.float64"
            case Bool => "Bool"
            case _ => throw new IllegalArgumentException("Sort " + s + " not supported")
          }
          val pargs = args.map({ case (n, s) => s"${n.prettyString}: ${ptype(s)}" }).mkString(", ")
          //@note ensure that args don't have both . and ._0
          assert(interpretation.forall(StaticSemantics.symbols(_).flatMap({
            case DotTerm(_, Some(i)) => Some(i)
            case DotTerm(_, None) => Some(0)
            case _ => None
          }).count(_ == 0) <= 1))
          val argsSubst = USubst(args.zipWithIndex.flatMap({ case ((Name(n, idx), s), i) =>
            (if (i == 0) List(SubstitutionPair(DotTerm(s, None), Variable(n, idx, s))) else Nil) :+
              SubstitutionPair(DotTerm(s, Some(i)), Variable(n, idx, s)) }))
          val body = interpretation match {
            case Some(i) => (new CFormulaTermGenerator(_ => ""))(argsSubst(i))._2
            case _ => PythonPrettyPrinter.numberLiteral(0.0) + " /* todo */"
          }
          s"""${name.prettyString}($pargs) -> ${ptype(codomain)}:
             |  return $body
             |""".stripMargin
      }).mkString("\n\n")
  }

  /** Generates a monitor `expr` that switches between a controller and a fallback controller depending on the monitor outcome. */
  private def generateMonitoredCtrlCCode(expr: Expression, stateVars: Set[BaseVariable], inputVars: Set[BaseVariable], fileName: String) : (String, String) = {
    val names = StaticSemantics.symbols(expr).map(nameIdentifier)
    require(names.intersect(PythonGenerator.RESERVED_NAMES).isEmpty, "Unexpected reserved Python names encountered: " +
      names.intersect(PythonGenerator.RESERVED_NAMES).mkString(","))
    val parameters = CodeGenerator.getParameters(expr, stateVars)

    val (bodyBody, bodyDefs) = bodyGenerator(expr, stateVars, inputVars, fileName)

    (printHeader(fileName) +
      IMPORT_STATEMENTS +
      printParameterDeclaration(parameters) +
      printStateDeclaration(stateVars) +
      printInputDeclaration(inputVars) +
      printVerdictDeclaration +
      printFuncDefs(expr, defs) +
      bodyDefs, bodyBody)
  }
}